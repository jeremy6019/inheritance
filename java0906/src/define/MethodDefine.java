package define;

public class MethodDefine {

	 /* 
	  ** method 
	     - 코드를 블록으로 묶고 이름을 부여해서 이름만으로 코드블록을 실행 시킬 수 있도록 해주는 것 
	     - class안에 만들면 method라고 하고 외부에 만들면 function(함수)이라고 합니다.
	     
	     1. 만드는 이유 
	     1) 자주 사용하는 코드를 유지보수를 잘 하기 위해서 한번만 기록하도록 하기 위해서 
	     2) 프로그램은 작업을 함수단위로 하는데 하나의 하무는 1MB의 공간을 할당받습니다. 
	         1MB를  넘게 사용하는 작업을 수행하게 되면 Stack Overflow가 발생합니다. 
	         이문제를 해결하기 위해서 함수단위로 분할을 해서 1MB이하의 작업을 만들어야 합니다. 
	     
	      2. 생성 
	      접근지정자 + 특성 + 리턴타입 + 메소드이름(매개변수 나열) {
	           내용;
	      } 
	      
	       3. 메소드 호출 
	       클래스이름 또는 인스턴스이름.메소드이름(매개변수값 나열);
	       - 자신의 클래스 안에서 호출할 때는 클래스 이름이나 인스턴스 이름을 생략할 수 있음  
	       
	       4. argument(매개변수)
	       - 메소드를 호출할 때 메소드에게 넘겨주는 데이터 
	       - 메소드에 매개변수가 있으면 메소드를 호출할때 반드시 매대변수를  같이 넘겨줘야 합니다. 
	       - 매개변수는 메소드 내에서만 사용이 가능한 지역변수 
	       - 매개변수의 개수에는 제한이 없습니다. 
	        
	        1) 매개변수 전달 방식 
	        - call by value :매개변수의 자료형이 기본형(데이터 1개저장 :boolean, byte,short, char, int, long,float,
	          double)인 경우로 이때  매개변수를 대입하면 데이터자체(value)가 전달됩니다. 
	          값이  전달되면 메소드 내에서 매개변수의 값을 변경하더라도 원본에는 아무런 영향이 없습니다. 
	        - call by reference : 매개변수의 자료형이 기본형이 아닌경우(배열,클래스의 인스턴스)로 이 때 매개변수를 
	          대입하면 참조가 전달됩니다. 
	          참조가 전달되면 메소드 내에서 매개변수 내부의 데이터를 변경하면 원본도 변경됩니다.   
	          
	          ## 다형성
	          call by value 와  call by reference 차이 
	          
	          2) method overloading(중복정의) ****
	          하나의 클래스에 메소드 이름은 같으나 매개변수의 개수나 자료형이 다른 메소드가 존재하는 경우 
	          메소드 오버로딩이라고 한다. 
	          - 알고리즘은 같은데 매개변수 형태가 달라서 이름을 다르게 만들면 이름이 너무 많이 필요   
	          
	          3) variable args(varargs)
	          매개변수의 개수에 상관없이 대입할 수 있도록 하는 문법
	          매개변수를 만들때 자료형 뒤에 .을 3개 기재하고 변수명을 만들면 메소드를 호출할때 몇개의 데이터를 
	          넘겨주던지 관계 없습니다. 
	          메소드내부에서는 배열로 처리합니다. 
	          - 데이터를 받아서 기술 통계 값을 계산해주는 메소드들이 이형식을 많이 사용합니다. 
	            데이터개수에 상관없이 알고리즘이 동일한 경우에 이용 
	          
	          ** return 
	          - 메소드의 수행을 중지하고 메소드를 호출한 곳으로 제어권을 넘겨주는 메소드 
	          - 메소드를 수행하고 그 결과를 호출한 곳으로 전달하고자 할때는 return 데이터를 하면 되는데 
	             이때 데이터의 자료형을 메소드 이름앞에 기재해 주어야 합니다. 
	          * void 는 return하는 데이터가 없을때 사용합니다.* 
	          - return하는 데이터가 있으면 메소드 수행결과를 이용해서 다른 작업에 이용할 수 있습니다. 
	          - 메소드가 return을 하는 경우에는 메소드의 수행결과를 변수에 저장한 후 이용하는 것이 좋습니다. 
	          
	          ** recursion - recursion call (재귀호출) 
	           - 메소드가 자기 자신을 다시 리턴하는  경우
	           - 메소드가 다른 메소드를 다시 호출하면 메모리 사용량이 늘어나고 속도는 느려집니다. 
	              재귀호출을 이용하는 이유는코드를 간결하고 이해하기 쉽게 만들 수 있기 때문입니다. 
	              
	              1-10까지의 합계 
	              10 + 9 까지의 합계 
	              // 1부터 n까지의 합계를 구해서 리턴해 주는 메소드 
	              public int sum(int n) {
	              int s = 0; 
	              for( int i=0; i<=n; i++){
	                  s+= i; 
	               }
	               return s;   
	               
	                public int sum(int n) { 
	                    if(n == 1) {
	                        return 1; 
	                    } else { 
	                       return n + sum(n-1)
	                    }
	                }
	                
	                sum(5); -> 5 + sum(4) -> 5 + 4+ sum(3) -> 5 + 4+ 3+ sum(2) -> 5+ 4+ 3+ 2+ sum(1) -> 5+4+3+2+1 
	               
	               재귀호출을 만들때 주의할 점은 종료 조건이 있어야 합니다. 
	               
	               피보나치 수열 - 나중에 반드시 직접 구현 
	               1,1,2,3,5,8,13,34,55,89,144... 
	               - 첫번째 와 두번째는 무조건 1 
	                  세번째부터는 이전 2개의 합
	                //n번째 피보나치 수열의 값을 리턴하는 메소드  
	                public int fibo(int n) { 
	                    int n1 = 1; 
	                    int n2 =1; 
	                    int result =1; 
	                    for(int i=3; i<=n; i++){
	                        result = n1 + n2; 
	                        n1 =n2; 
	                        n2 = result; 
	                    }
	                    return result;	                     
	                }
	                
	                //재귀를 이용한 피보나치 수열 메소드 
	                 public int fibo(int n) {
	                     if(n==1 || n==2) {
	                     return 1; 
	                     } else {
	                         return fibo(n-1) + fibo(n-2); 
	                    }
	                }
	               
	              * this 
	               - 인스턴스 메소드의 숨겨진 첫번째 매개변수 
	               - 인스턴스 메소드가 코드로 만들어질때 자동 추가 
	                자료형은 자신의 클래스 타입이고 인스턴스메소드를 호출할때  인스턴스의 참조가 자동 대입 
	               - 인스턴스 메소드 안에 인스턴스 변수와 동일한 이름의 지역변수가 있는 경우 
	                  인스턴스변수를 호출할때 사용 
	                # 메소드는 클래스가 소유 
	                
	                public calss T { 
	                    public int x ; // 인스턴스 변수 x를 만듬 
	                    
	                    public void set x (int y) {
	                        int x; 
	                        x =y ; // this.x라고 하면 인스턴스 변수 x를 가지고 옴  
	                    }                    
	                    
	               }
	               
	               *
	                 지역변수 :  _변수명 
	                 인스턴스: m_변수명 
	                 static : g_변수명 
	                 
	                 this.을 찍으면 코드센스 동작시킬 수 있다 인스턴스변수를 찾을 수 있다 . . 
	                 
	                 * static 
	                 -  메소드의 return type앞에 static추가하면 클래스 이름 호출 가능 
	                 - 인스턴스 변수 사용 못함 (this 가 없음) 
	                 - 인스턴스 변수가 필요없을 때 static 메소드로 만들면 편리 
	                 - 바로 참조가 가능함. 
	                 
	               
	               
	             T ob = new T();
	             ob. set x(100); //메소드 호출시 자신의 참조가 this에 대입 
	          
	          
	          
	          
	          
	          
	          
	  */
}

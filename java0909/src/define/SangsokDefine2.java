package define;

public class SangsokDefine2 {

	/* 
               ** 상속(inheritance)
                 - 하위 클래스가 상위클래스의 모든 것을 물려 받는 것 
                 - private은 상속이 안 되는것이 아니고 상속은 되지만 숨겨진 채로 상속이 되기 때문에 
                   하위클레스에서 접근을 하지 못합니다. (not visible) 
                
                    # Base Class / Drived Class,    Super class / Sub Class 
                    
                1. 상속을 하는 이유 
                  1) 제공되는 클래스를 상속하는 경우 
                    - 제공되는 클래스의 기능이 부족해서 기능을 추가하기 위해서 입니다. 
                       제공하는 입장에서는 공통적으로 많이 사용하는 기능만 작성해서 제공하기 때문입니다. 
                
                 2) 직접 작성한 클래스를 상속하는 경우 
                    - 여러 클래스에서 공통된 코드가 있어서 상위클래스에 만들어 두고 재사용하기 위해서 
                    - 다형성(Polymorphism- 동일한 메세지에 대하여 다르게 반응하는 성질)을 구현하기 위해서  
                    - 자신이 만든 SW를 업그레이드 하기 위해서 기능 확장을 하는 경우도 있기는 하지만 자신이 만든것이면 
                       클래스를 변경하는 경우가 더 많습니다. 
                    - 코드 리뷰할 때 하는 경우가 더 많습니다. 
                
                2. 상속을 하는 방법 
                   class 클래스 이름 extends 상위클래스 이름 
                   - 상속은 하나의 클래스부터만 가능합니다. - 단일 상속  
                   - extends를 생략하면 java.lang.Object라는 클래스로부터 상속받습니다. 
                   
                3. 상속 
                - private 멤버는 상속은 되지만 하위클래스에서 가려져 있기때문에 접근이 불가능 
                - 초기화 블록이나 생성자는 상속되지 않습니다. 
                - * static변수는 상속이 됩니다.* 
                - 상속받은 클래스의 객체를 생성할때는 상위 클래스의 생성자를 호출해서 상위클래스의 객체를 만들고 
                   이후에 하위클래스의 생성자를 호출해서 하위클래스의 내용을 붙이는 형태로 객체를 생성   
                - 상위클래스를 Base, super클래스라고 하고 하위클래스를 Derived, Sub클래스라고 합니다. 
                
                 4. 클래스 안의 메소드에서 변수(속성)이나 메소드를 호출했을 때 찾는 순서
                 
                 1) 변수 
                   - 이름만 사용한 경우 메소드 내에서 찾아보고 없으면 자신의 클래스에서 찾고 그래도 없으면 상위클래스에서 
                     찾아서 사용 
                   -  상위클래스에도 없으면 에러 
                 
                 2) 메소드 
                   - 자신의 클래스에서 찾아서 호출하고 없으면 상위 클래스에서 찾아서 호출 
                 
                 3) this 
                   - 메소드 내부에서는 찾지 않으려고 할 때는 this. 변수 형태로 호출하면 됩니다. 
                 
                 4) super 
                    - 상위 클래스에서 찾을려고 할때 super.변수 형태로 호출하면 됩니다. 
                    
               5. 상속관계에서의 생성자 
                 1) 하위클래스의 생성자를 호출하면 상위클래스의 생성자가 먼저 호출되서 수행되고 그다음에 
                 하위클래스의 생성자가 호출되서 수행 
                 
                 2) 하위클래스의생성자에는 아무런 내용을 작성하지 않아도 상위클래스의 default constructor(매개변수가
                 없는 생성자)를 호출하는 구문이 있는 것으로 간주 
		         
		         3) 상위클래스에서 생성자를 만들때 매개변수가 없는 생성자를 만들지 않으면 하위클래스는 에러가 발생합니다.
		         이때는 하위클래스에서 생성자를 만들고 첫번째  라인에서 super(매개변수)를 이용해서 상위클래스의 생성자를 
		         직접 호출해야 합니다.  
		            
		         Implicit super constructor Super() is undefined for default constructor. Must define an explicit constructor
		         ==>Super클래스에는 매개변수가 없는 생성자가 없어서 반드시 생성자를 만들어야 합니다.    
		                 
	            **Polymorphism(다형성) 
	               - 동일한 메세지에 대하여 다르게 반응하는 성질  
	               - 동일한 코드가 상황에 따라 다른 메소드를 호출하는 것 
	               
	               1) Method Overriding 
	                - 상위클래스와 하위클래스에 동일한 원형의 메소드가 존재하는 경우 
	                - 메소드의 원형은 메소드이름과 매개변수의 개수와 자료형을 의미 
	                - 다형성 구현이나 기능추가를 위해서 사용 
	                - 자바에서는 하위클래스에 만들어지는 메소드의 접근 지정자가 상위클래스의 메소드 접근 지정자보다 
	                   크거나 같아야 합니다. 
	                   public > protected > default > private 
	                - overriding된 메소드 안에서 상위클래스의 메소드를 호출할때는super.메소드이름()의 형태이어야 합니다.
	                  하위클래스에 메소드 오버라이딩을 할때는 오버라이딩 되었다는 의미를 명시적으로 전달하기 위해서 
	                  @Override를 추가하기도 합니다. 
	                  @로 시작하는 것을 annotation이라고 하느데 @Override가 있는데 상위클래스에 동일한 메소드가 없으면 
	                  에러가 발생 
	               
	                   - 안드로이드와 같은 프레임워크가 제공하느 클래스의 메소드를 오버라이딩할때는 메소드가 추상메소드가 
	                      아니라면 상위클래스의 메소드를 반드시 호출해야합니다. 
	                      *내가 만들지 않은 제공해주는 클래스로부터 상속을 받는 경우는 기본기능에 기능을 추가하기 위해서 입니다. *
	                 
	                 2. 참조형 변수의 대입 - 반드시 기억 !!!!! 
	                  - 상위클래스의 참조형 변수에는 하위클래스 객체의 참조를 형 변환없이 바로 대입이 가능  
	                  - 하위클래스의 참조형 변수에 상위클래스 객체의 참조를 형 변환없이는 대입이 안됩니다. 
	                     이 경우에는 하위클래스 타입으로 강제 형 변환을 해서 대입을 하면 문법적인 에러는 없습니다. 
	                  - 상속관계가 아닌 경우에는 참조형 변수에 다른 클래스 객체 참조를 대입할 수 없습니다. 
	                   
	                  - 하위클래스는 상위클래스의 모든 것을 물려받았기 때문에 상위클래스가 요구하는 모든 것을 제공할 수 있지만
	                     상위클래스는 하위클래스가 요구하는 모든 것을 제공할 수 없습니다. 
	                     강제 형 변환을 해서 대입은 가능한데 원래의 자료형이 하위 클래스타입이 아니라면 실행 중 에러(예외 발생)
                      
                      3. 참조형 변수의 속성이나 메소드 호출 
                        1) 참조형 변수는 변수를 선언할 때 의 자료형을 가지고 속성이나 메소드를 선택합니다. 
                        2) 예외적으로 오버라이딩된 메소드를 호출할 때는 선언할때의 자료형을 가지고 호출하지 않고 대입될 때
                            (객체)의 자료형을 가지고 메소드를 호출합니다. 
                        3) 변수를 선언할 때의 자료형을 가지고 판단하는 것을 정적(static)바인딩이라고 하고 대입되는 객체를 가지고 
                            판단하는 것을 동적(dynamic)바인딩이라고 합니다. 
	                     
	                      
	                   ** 용어 
	                   1. library(package): 프로그램을 만들때 하나의 기능을 만들어 주기 위해 제공되는 것 
	                   
	                   2. framework: 프로그램 전체를 만들기 쉽게 해주거나 프로그램의 일부분을 만들기 쉽게 해주기 위해서 제공 
	                       되는 것
	                       
	                   3. Solution: 특수한 목적의 프로그램을 개발하는 것을 쉽게 해주기 위한 프로그램   
	                     	 
	 
	 */
	
	
	
	
	
	
}
